{"meta":{"title":"Be Humble,sit down!","subtitle":"Dig -Fixn'work it out","description":null,"author":"Stan Young","url":"http://yangxinyang777.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"【数据结构】chapter2-线性表","date":"2019-10-20T11:19:35.572Z","updated":"2019-10-20T13:29:34.819Z","comments":true,"path":"2019/10/20/【数据结构】chapter2-线性表/","link":"","permalink":"http://yangxinyang777.github.io/2019/10/20/【数据结构】chapter2-线性表/","excerpt":"【数据结构】chapter2 线性表","text":"【数据结构】chapter2 线性表 线性表n个数据元素构成线性表，n为表的长度，一个数据元素可由若干数据项构成。（逻辑结构）典型的线性存储结构。 线性表的顺序存储顺序存储结构将线性表的元素按其逻辑次序依次存入一段地址连续的存储单元里。用这种方法存储的线性表叫顺序表。 第一个元素的存储位置为基地址。 线性表的顺序存储在机内表示为（物理结构）顺序存储结构。 实现C++类定义1234567891011121314151617181920template &lt;class T&gt;//考虑到表元素的数据类型可以是多样的，这里利用类模板，使用时以目标数据类型代替T即可class SeqList&#123;private://私有变量 int length; int MaxSize; T *data;//T类型的指针，指向datapublic: friend void Converts(SeqList&lt;T&gt; &amp;L);//友元函数 SeqList(int MaxListSize = 100);//设置构造函数默认参数为100 ~SeqList()&#123; delete[]data; &#125;//析构函数。构造函数每被调用一次，析构函数就要被调用一次。 bool ListEmpty()&#123; return length == 0; &#125;//判断表是否为空 int ListLength()&#123; return length; &#125;//返回表长度 bool GetElem(int i, T &amp;x);//取第i并将其赋值给x int LocateElem(T x);//返回x所在位置 void InsertElem(int i, T x);//在第i处插入x void DeleteElem(int i, T &amp;x);//删除第i处的值，i之后的值前移 void PrintList();//输出表&#125;;​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#### 成员函数实现```c++template &lt;class T&gt;//模板说明SeqList&lt;T&gt;::SeqList(int MaxListSize)//&quot;::&quot;限定符 &#123; MaxSize = MaxListSize; data = new T[MaxSize];//创建T类型大小为MaxSize的数组并将地址赋给data length = 0;//无数据，长度为0&#125;//构造函数template &lt;class T&gt;bool SeqList&lt;T&gt;::GetElem(int i, T &amp;x)//x作为实参传递进来，考虑到在函数调用完毕后值应该发生变化，应当使用“引用”的方法即 &amp;x；&#123; if (i&lt;1 || i&gt;length) return false;//判断第i个元素是否存在 x = data[i - 1];//序号实参i从1开始，计算机存储从0开始 return true;&#125;//取第i个元素template &lt;class T&gt;int SeqList&lt;T&gt;::LocateElem(T x)&#123; for (int i = 0; i &lt; length; i++) if (data[i] == x) return ++i; return 0;&#125;//查找值为x的元素template &lt;class T&gt;void SeqList&lt;T&gt;::InsertElem(int i, T x)&#123; if (i&lt;1 || i&gt;length + 1) &#123; cout &lt;&lt; &quot;position error!&quot; &lt;&lt; endl;//判断 return; &#125; for (int j = length - 1; j &gt; +i + 1; j--) &#123; data[j + 1] = data[j];//循环赋值，使从插入位以后的值皆往后移动一位 &#125; data[i - 1] = x; length ++;&#125;//插入值template &lt;class T&gt;void SeqList&lt;T&gt;::DeleteElem(int i, T &amp;x)//引用&#123; if (i&lt;1 || i&gt;length + 1) &#123; cout &lt;&lt; &quot;position error!&quot; &lt;&lt; endl; return; &#125; x = data[i - 1]; for (int j = i; j &lt; length; j++) &#123; data[j - 1] = data[j];//循环赋值，使从删除位以后的值皆向前移动一位 &#125; length --;&#125;//删除值，返回被删除的元素值template &lt;class T&gt;void SeqList&lt;T&gt;::PrintList()&#123; for (int i = 0; int length; i++) &#123; cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//输出表template &lt;class T&gt;void Converts(SeqList&lt;T&gt; &amp;L)//友元函数&#123; int x; int i, j; k = L.length / 2;//以中间位置为交换终点，首尾对应位置元素值交换 for (i = 0; i &lt; k; i++) &#123; x = k.data[i]; L.data[i] = L.data[length - i - 1]; L.data[length - i - 1] = x; &#125;&#125;//逆置 12 使用实例123456789101112131415161718# include\"mylist.h\"# include\"stdio.h\"# include\"iostream\"using namespace std;void main(void)&#123; SeqList&lt;int&gt; L(6); cout &lt;&lt; \"IsEmpty = \" &lt;&lt; L.ListEmpty() &lt;&lt; endl; cout &lt;&lt; \"length = \" &lt;&lt; L.ListLength() &lt;&lt; endl; SeqList&lt;char&gt;B(6); B.InsertElem(1, 'a'); B.InsertElem(2, 'h'); B.InsertElem(3, 'a'); B.InsertElem(4, 'h'); B.PrintList();&#125;​ ## 线性表的链式存储 ### 链式存储 当需要存储的元素间存在很多空值，而这些空值不需要存储的时候可以使用链式存储结构。 且顺序存储结构的表长是固定的，容易产生空间的溢出。 ***链式存储结构*** 表示每个元素在存储的时候，不仅要存储其值，还要存储一个指向其***后继元素***存储位置的***指针***，这两个值组成的该元素的在计算机中的存储映像，称为***结点***，其包括***数据域***和***指针域***，以这种方式生成的表其结点的只包含一个指针域，也因此被叫做***单链表***。 线性表的链式存储在机内表示为（物理结构）**链式存储结构**。 ### 实现 #### C++类定义","categories":[],"tags":[]},{"title":"","slug":"【前端】动态登陆窗口","date":"2019-10-18T15:53:10.648Z","updated":"2019-10-18T16:29:46.673Z","comments":true,"path":"2019/10/18/【前端】动态登陆窗口/","link":"","permalink":"http://yangxinyang777.github.io/2019/10/18/【前端】动态登陆窗口/","excerpt":"【前端】动态登陆窗口","text":"【前端】动态登陆窗口 效果展示 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;MainWin&quot;&gt;​ &lt;h1 class=&quot;head &quot;&gt;欢迎&lt;/h1&gt;​ &lt;form action=&quot;&quot; onsubmit=&quot;return true&quot;&gt;​ &lt;h1&gt;用户名:&lt;/h1&gt;​ &lt;input type=&quot;text&quot; id=&quot;name&quot; placeholder=&quot;请输入用户名...&quot;&gt;&lt;br/&gt;​ &lt;h1&gt;密码:&lt;/h1&gt;​ &lt;input type=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码...&quot;&gt;&lt;br/&gt;​ &lt;input type=&quot;button&quot; value=&quot;确定&quot; class=&quot;button&quot; onclick=&quot;window.open(&apos;index.html&apos;)&quot;&gt;​ &lt;input type=&quot;submit&quot; value=&quot;注册&quot; class=&quot;button&quot;&gt;​ &lt;form/&gt;​ &lt;/div&gt;​ &lt;/div&gt; &lt;style&gt;​ body&#123;​ margin: 0;​ padding: 0;​ background-color: #573c4c;​ &#125;​ body , html&#123;​ height: 100%;​ &#125;​ .main&#123;​ /*margin:20% auto 20% auto;*/​ margin-top: 0 ;​ padding: 0;​ height: 100%;​ width: 100%;​ background-color: #757575;​ /* background:url(&quot;pic/login_backgroud.jpg&quot;) no-repeat;​ background-size:100% 100%; */​ position:absolute;​ display: flex;​ /*一种布局方式*/​ justify-content: center;​ /*使main处于bady中心*/​ align-items: center;​ /*居中对齐main中的div元素*/​ &#125;​ .MainWin&#123;​ padding: 20px;​ background-color:#fff;​ height: 250px;​ width: 350px;​ &#125;​ .head&#123;​ font-size: 50px;​ color: #757575;​ text-align: center;​ &#125;​ .MainWin h1&#123;​ font-family: &quot;微软雅黑&quot;;​ font-size: 15px;​ color: #757575;​ &#125;​ .MainWin input[type=&quot;text&quot;], input[type=&quot;password&quot;]&#123;​ border: none;​ border-bottom: 3px solid #757575;​ width: 100%;​ padding: 5px 0;​ letter-spacing: 1px;​ transition: border-bottom-color .45s ;​ &#125;​ .MainWin input[type=&quot;button&quot;]&#123;​ margin-right:8.5%;​ margin-top: 10%;​ border: 2px solid #fff;​ width: 45%;​ height: 30px;​ background-color: #1eeb8e;​ color: #fff;​ transition: border .5s;​ /*position: absolute;*/​ &#125;​ .MainWin input[type=&quot;submit&quot;]&#123;​ margin-top: 10%;​ border: 2px solid #fff;​ width: 44%;​ height: 30px;​ background-color: #1eeb8e;​ color: #fff;​ transition: border .5s;​ /*position: absolute;*/​ &#125;​ .MainWin input[type=&quot;button&quot;]:hover&#123;​ border: 2px solid #1eeb8e;​ &#125;​ .MainWin input[type=&quot;submit&quot;]:hover&#123;​ border: 2px solid #1eeb8e;​ &#125;​ .MainWin input[type=&quot;text&quot;]:hover&#123;​ border-bottom-color: #f7abe9;​ &#125;​ .MainWin input[type=&quot;password&quot;]:hover&#123;​ border-bottom-color: #f7abe9;​ &#125;​ &lt;/style&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"","slug":"数据结构学习笔记01","date":"2019-10-18T14:48:56.509Z","updated":"2019-10-18T15:12:01.707Z","comments":true,"path":"2019/10/18/数据结构学习笔记01/","link":"","permalink":"http://yangxinyang777.github.io/2019/10/18/数据结构学习笔记01/","excerpt":"【数据结构】chapter 1","text":"【数据结构】chapter 1 思维导图 补充ADT (Abstract Data Type)一个定义了相关操作运算的数学模型，以“圆”为例。（C语言） ADT Circle{ ​ Date //数据 ​ 非负实数 //作为半径 ​ Operations //操作 ​ Constructor //建立 ​ 输入：非负实数 ​ 处理：给圆的半径赋值 ​ Area //求面积 ​ 输入：半径 ​ 处理：计算面积 ​ 输出：面积 ​ Circumference //求周长 ​ 输入：半径 ​ 处理：计算周长 ​ 输出：周长 }// ADT Circle 这样，就建立了一个Cricle抽象数据类型，定义在该数据类型上的一些操作为：Constructor、Area、Circleumference","categories":[],"tags":[]},{"title":"","slug":"基于高德地图WebAPI的WebGIS前端界面搭建","date":"2019-10-13T14:14:06.620Z","updated":"2019-10-18T15:52:29.641Z","comments":true,"path":"2019/10/13/基于高德地图WebAPI的WebGIS前端界面搭建/","link":"","permalink":"http://yangxinyang777.github.io/2019/10/13/基于高德地图WebAPI的WebGIS前端界面搭建/","excerpt":"基于高德地图WebAPI的WebGIS前端页面搭建","text":"基于高德地图WebAPI的WebGIS前端页面搭建 成果展示登陆界面 主界面 基本概念WebGIS 什么是WebGIS？就是将GIS这门学科所能提供的功能，以B/S技术展现给用户，使用户只需要在浏览器上便能使用这些GIS功能。与其他全栈式开发相同，但WebGIS更侧重的是在应用层的地图服务。 前端如所有的Web项目一样，前端由HTML、CSS、JS、Flex等语言组成。 中间件开发时，我们要选择适合自己的中间件。不同的中间件有其特性，如果是一般项目，tomcat等是很合适的，其使用方便，相关技术支持和资料也很好查找。但是如果是大型的集群项目，Weblogic和WebShpere可能是更好的选择，但是这两个中间件首先配置就是有难度的，同时不同的版本，可能对某些jar包的支持存在问题。如果项目必须使用国产的中间件，TongWeb和Apusics是不错的选择。 地图服务器在WebGIS中，与其他一般的Web工程有明显区别的就体现在地图服务器上面。一般的地图服务器都由已有的软件商提供了解决方案，比较流行的有AGS、Geoserver、MapServer、SuperServer等。利用这些地图服务器我们能很好的实现地图的发布以及对一些空间查询和空间操作的支持。 业务服务器业务服务器是Web项目里不可获取的一环。不管是利用哪些已有框架编写，比如Spring、Struts、Hibernate等，我们一般还是会将业务服务器的实现分为三个层次，即有名的MVC模式。而不同的框架里这三个层次的实现各有差别。 数据WebGIS的数据大致可以分为三种，一种是地图、影像数据，一种是空间属性数据、一种是业务数据。地图、影像数据一般是一些png或者其他格式的数据组成。 在GIS中有个很重要的概念，即影像金字塔。这个概念主要是为了加速地图在前端的显示。而我们准备地图、影像数据时，也一般会首先对这些数据进行切图。 空间属性数据，是通过一些工具将已经整理好的数据进行入库。对于AGS，只有连接的是入库数据的mxd，才能发布成FeatureServer服务，以供数据的编辑。当然，空间数据入库后还可以支持业务逻辑的使用。 第三种数据，业务逻辑数据，是每个Web项目必须有的，它根据不同的业务需求将业务所需的数据进行采集和入库。 前端框架动态登陆窗口二级下拉菜单高德地图WebAPI调用","categories":[],"tags":[]}]}