{"meta":{"title":"Be Humble,sit down!","subtitle":"Dig -Fixn'work it out","description":null,"author":"Stan Young","url":"http://yangxinyang777.github.io","root":"/"},"pages":[],"posts":[{"title":"约 瑟 夫 环","slug":"约-瑟-夫-环","date":"2019-11-11T13:25:02.000Z","updated":"2019-11-11T13:36:15.363Z","comments":true,"path":"2019/11/11/约-瑟-夫-环/","link":"","permalink":"http://yangxinyang777.github.io/2019/11/11/约-瑟-夫-环/","excerpt":"","text":"约瑟夫环问题编号是1，2，……,n的n个人按照顺时针方向围坐一圈，每个人只有一个密码（正整数）。一开始任选一个正整数作为报数上限值m,从第一个仍开始顺时针方向自1开始顺序报数，报到m时停止报数。报m的人出列，将他的密码作为新的m值，从他在顺时针方向的下一个人开始重新从1报数，如此下去，直到所有人全部出列为止。设计一个程序来求出出列顺序。 解题思路定义循环链表节点类，定义一个返回指向约定为第一个结点的指针的创建循环链表函数。在主函数中实现人数与上限值的约定并读入key，通过删除结点的操作直至链表为空。以下给出C语言的解决方案。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include \"stdlib.h\"#include \"stdio.h\"typedef struct node&#123; int data; struct node *next;&#125;node;//创建循环链表函数，返回值为指向“头结点”的指针，指针域皆为0node *CreateList(int n)&#123; node *head = NULL, *p; head = (node *)malloc(sizeof(node)); p = head; node *s=NULL; int i; if (n == 0) printf(\"error!\"); else for (i = 1; i &lt;= n; i++)&#123; s = (node *)malloc(sizeof(node)); s-&gt;data = 0; p-&gt;next = s; p = s; &#125; s-&gt;next = head-&gt;next; return s-&gt;next;&#125;int main()&#123; int n, m; int i = 1; node *temp, *p;//临时指针，用以指向即将删除的结点；工作指针，指向即将被操作的结点。 printf(\"请输入人数：\"); scanf_s(\"%d\",&amp;n); p = CreateList(n); printf(\"请输入报数上限：\"); scanf_s(\"%d\", &amp;m); while(i &lt;= n)&#123; scanf_s(\"%d\",&amp;p-&gt;data); if (p-&gt;data &gt; m||p-&gt;data&lt;=0)&#123; printf(\"不合法！请重新输入\\n\"); scanf_s(\"%d\", &amp;p-&gt;data); &#125;//添加指针域数值限制条件 p = p-&gt;next; i++; &#125; int j = 1;//计数器 while (p != p-&gt;next)&#123; for (i = 1; i &lt; m - 1; i++)&#123; p = p-&gt;next; &#125; temp = p-&gt;next; p-&gt;next = temp-&gt;next; p = p-&gt;next; printf(\"Key为 %d 的人是第 %d 个出列的\\n\", temp-&gt;data, j); free(temp);//释放结点 j++; &#125; printf(\"Key为 %d 的人是最后一个出列的\\n\", p-&gt;data); system(\"pause\"); return 0;&#125; 12","categories":[],"tags":[]},{"title":"【数据库】chapter1 引论","slug":"【数据库】chapter1-引论","date":"2019-10-28T12:41:08.000Z","updated":"2019-10-28T13:43:30.837Z","comments":true,"path":"2019/10/28/【数据库】chapter1-引论/","link":"","permalink":"http://yangxinyang777.github.io/2019/10/28/【数据库】chapter1-引论/","excerpt":"数据处理和管理是计算机应用最重要的领域，数据库系统的知识对于 计算机学者至关重要。","text":"数据处理和管理是计算机应用最重要的领域，数据库系统的知识对于 计算机学者至关重要。 【数据库】chapter1 引论Xmind","categories":[],"tags":[]},{"title":"【数据结构】chapter2 线性表","slug":"【数据结构】chapter2-线性表","date":"2019-10-20T11:19:35.572Z","updated":"2019-10-28T13:18:58.322Z","comments":true,"path":"2019/10/20/【数据结构】chapter2-线性表/","link":"","permalink":"http://yangxinyang777.github.io/2019/10/20/【数据结构】chapter2-线性表/","excerpt":"表是数据结构中重要的一种存储方式，它可以有顺序存储与链式存储两种方式，其中链式存储的使用最为广泛，也最为复杂。","text":"表是数据结构中重要的一种存储方式，它可以有顺序存储与链式存储两种方式，其中链式存储的使用最为广泛，也最为复杂。 【数据结构】chapter2 线性表 线性表n个数据元素构成线性表，n为表的长度，一个数据元素可由若干数据项构成。（逻辑结构）典型的线性存储结构。 线性表的顺序存储顺序存储结构将线性表的元素按其逻辑次序依次存入一段地址连续的存储单元里。用这种方法存储的线性表叫顺序表。 第一个元素的存储位置为基地址。 线性表的顺序存储在机内表示为（物理结构）顺序存储结构。 实现C++类定义12345678910111213141516171819template &lt;class T&gt;//考虑到表元素的数据类型可以是多样的，这里利用类模板，使用时以目标数据类型代替T即可class SeqList&#123;private://私有变量 int length; int MaxSize; T *data;//T类型的指针，指向datapublic: friend void Converts(SeqList&lt;T&gt; &amp;L);//友元函数 SeqList(int MaxListSize = 100);//设置构造函数默认参数为100 ~SeqList()&#123; delete[]data; &#125;//析构函数。构造函数每被调用一次，析构函数就要被调用一次。 bool ListEmpty()&#123; return length == 0; &#125;//判断表是否为空 int ListLength()&#123; return length; &#125;//返回表长度 bool GetElem(int i, T &amp;x);//取第i并将其赋值给x int LocateElem(T x);//返回x所在位置 void InsertElem(int i, T x);//在第i处插入x void DeleteElem(int i, T &amp;x);//删除第i处的值，i之后的值前移 void PrintList();//输出表&#125;; 12 成员函数实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283template &lt;class T&gt;//模板说明SeqList&lt;T&gt;::SeqList(int MaxListSize)//\"::\"限定符 &#123; MaxSize = MaxListSize; data = new T[MaxSize];//创建T类型大小为MaxSize的数组并将地址赋给data length = 0;//无数据，长度为0&#125;//构造函数template &lt;class T&gt;bool SeqList&lt;T&gt;::GetElem(int i, T &amp;x)//x作为实参传递进来，考虑到在函数调用完毕后值应该发生变化，应当使用“引用”的方法即 &amp;x；&#123; if (i&lt;1 || i&gt;length) return false;//判断第i个元素是否存在 x = data[i - 1];//序号实参i从1开始，计算机存储从0开始 return true;&#125;//取第i个元素template &lt;class T&gt;int SeqList&lt;T&gt;::LocateElem(T x)&#123; for (int i = 0; i &lt; length; i++) if (data[i] == x) return ++i; return 0;&#125;//查找值为x的元素template &lt;class T&gt;void SeqList&lt;T&gt;::InsertElem(int i, T x)&#123; if (i&lt;1 || i&gt;length + 1) &#123; cout &lt;&lt; \"position error!\" &lt;&lt; endl;//判断 return; &#125; for (int j = length - 1; j &gt; +i + 1; j--) &#123; data[j + 1] = data[j];//循环赋值，使从插入位以后的值皆往后移动一位 &#125; data[i - 1] = x; length++;&#125;//插入值template &lt;class T&gt;void SeqList&lt;T&gt;::DeleteElem(int i, T &amp;x)//引用&#123; if (i&lt;1 || i&gt;length + 1) &#123; cout &lt;&lt; \"position error!\" &lt;&lt; endl; return; &#125; x = data[i - 1]; for (int j = i; j &lt; length; j++) &#123; data[j - 1] = data[j];//循环赋值，使从删除位以后的值皆向前移动一位 &#125; length--;&#125;//删除值，返回被删除的元素值template &lt;class T&gt;void SeqList&lt;T&gt;::PrintList()&#123; for (int i = 0; int length; i++) &#123; cout &lt;&lt; data[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;//输出表template &lt;class T&gt;void Converts(SeqList&lt;T&gt; &amp;L)//友元函数&#123; int x; int i, j; k = L.length / 2;//以中间位置为交换终点，首尾对应位置元素值交换 for (i = 0; i &lt; k; i++) &#123; x = k.data[i]; L.data[i] = L.data[length - i - 1]; L.data[length - i - 1] = x; &#125;&#125;//逆置 12 使用实例1234567891011121314151617# include\"mylist.h\"# include\"stdio.h\"# include\"iostream\"using namespace std;void main(void)&#123; SeqList&lt;int&gt; L(6); cout &lt;&lt; \"IsEmpty = \" &lt;&lt; L.ListEmpty() &lt;&lt; endl; cout &lt;&lt; \"length = \" &lt;&lt; L.ListLength() &lt;&lt; endl; SeqList&lt;char&gt;B(6); B.InsertElem(1, 'a'); B.InsertElem(2, 'h'); B.InsertElem(3, 'a'); B.InsertElem(4, 'h'); B.PrintList();&#125; 12 线性表的链式存储链式存储当需要存储的元素间存在很多空值，而这些空值不需要存储的时候可以使用链式存储结构。 且顺序存储结构的表长是固定的，容易产生空间的溢出。 链式存储结构 表示每个元素在存储的时候，不仅要存储其值，还要存储一个指向其后继元素存储位置的指针，这两个值组成的该元素的在计算机中的存储映像，称为结点，其包括数据域和指针域，以这种方式生成的表其结点的只包含一个指针域，也因此被叫做单链表。 线性表的链式存储在机内表示为（物理结构）链式存储结构。 开始结点无直接前驱，所以链表需要一个头指针指向开始结点。 单链表可由一个头指针唯一确定。 因此链式存储结构的类定义包含链表类定义：成员函数定义，头指针定义（有其指向结点类，实现方法为将其包含为结点类的友元类） 结点类：公共部分需声明友元类（链表类），私有部分定义结点（数据域，结点域）。 实现C++类定义123456789101112131415161718192021222324252627282930313233template&lt;class T&gt;class ListNode&#123;//结点类定义public: friend class LinkList &lt; T &gt; ;//实现友元类（LinkList）的成员函数对当前类（ListNode）的私有成员的访问。 friend void InsertList(LinkList&lt;T&gt; &amp;L, int x); friend void split(LinkList&lt;T&gt; L, LinkList&lt;T&gt; &amp;A, LinkList&lt;T&gt; &amp;B); friend void MergetList(LinkList&lt;T&gt; La, LinkList&lt;T&gt; Lb, LinkList&lt;T&gt; &amp;Lc);private: T data; ListNode&lt;T&gt;* next;&#125;;template &lt;class T&gt;class LinkList&#123;//链表类定义public : LinkList()&#123; head = null; &#125; ~LinkList()&#123;&#125;; bool ListEmpty()&#123; return head == null; &#125; int ListLength(); void CreateListF(); void CreateListR(); void CreateList(); bool GetElem(int i, T &amp;x); int LocateElem(T x); void InsertNode(int i,T x); void DeleteNode(int i, T &amp;x); void PrintList(); friend void InsertList(LinkList&lt;T&gt; &amp;L, int x); friend void split(LinkList&lt;T&gt; L, LinkList&lt;T&gt; &amp;A, LinkList&lt;T&gt; &amp;B); friend void MergetList(LinkList&lt;T&gt; La, LinkList&lt;T&gt; Lb, LinkList&lt;T&gt; &amp;Lc);private: ListNode&lt;T&gt; *head;//定义一个指向结点类的指针，取名为head。&#125;; 12 成员函数定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162template&lt;class T&gt;void LinkList&lt;T&gt;::CreateListF()&#123; ListNode&lt;T&gt; *p = head, *s;//先使用构造函数，此时head=null。 T ch; ch = getchar(); while (ch != '\\n'); &#123; s = new ListNode &lt; T &gt;; s-&gt;data = ch; s-&gt;next = p; p = s; ch = getchar(); &#125; head = p;&#125;//头插法建表template&lt;class T&gt;void LinkList&lt;T&gt;::CreateListR()&#123; ListNode&lt;T&gt; *rear = NULL , *s;//一个负责使用，一个负责建造 T ch; ch = getchar(); while (ch != '\\n') &#123; s = new ListNode &lt; T &gt; ; s-&gt;data = ch; if (head == NULL) //若无头指针 &#123; head = s; &#125; else rear-&gt;next = s; rear = s;//使用s开辟的结点 ch = getchar(); &#125; rear-&gt;next = NULL;//终止结点指针域为空&#125;//尾插法建表1template&lt;class T&gt;void LinkList&lt;T&gt;::CreateList()&#123; ListNode&lt;T&gt; *s, *rear = NULL; T ch; head = new ListNode &lt; T &gt; ; rear = head;//建立头结点并使rear与head都指向该结点 ch = getchar(); while (ch!= '\\n') &#123; s = new ListNode &lt; T &gt; ; s-&gt;data = ch; rear-&gt;next = s;//建立头结点与新建结点的联系 rear = s;//更改rear指向 ch = getchar(); &#125; rear-&gt;next = NULL;&#125;//头结点尾插法建表template&lt;class T&gt;bool LinkList&lt;T&gt;::GetElem(int i, T &amp;x)&#123; int j = 1; ListNode&lt;T&gt; *p = head-&gt;next;//从头开始 while (j &lt; i&amp;&amp;p)//直到第i个元素，p指向该元素 &#123; p = p-&gt;next; j++; &#125; if (p)//如果p是真的 &#123; x = p-&gt;data;//p所指向的结点的数据域的值赋给x return true;//找到了 &#125; return false;//没找到&#125;//按结点序号查找运算template&lt;class T&gt;int LinkList&lt;T&gt;::LocateElem(T x)&#123; ListNode&lt;T&gt; *p = head-&gt;next; int num = 0; while (p&amp;&amp;p-&gt;data != x)//当p是真的且指向的结点的数据域的值不为X时 &#123; num++;//计数器加一 p = p-&gt;next;//p指向下一个结点 &#125; if (p)//如果p时真的时候 &#123; return ++num;//返回num+1后的值 &#125; else return -1;&#125;//按结点值查找template&lt;class T&gt;void LinkList&lt;T&gt;::InsertNode(int i, T x)&#123; if (i&lt;1 || i&gt;ListLength())//当i不符合条件时 &#123; cout &lt;&lt; \"position error!\\n\";//输出错误提示 return; &#125; ListNode&lt;T&gt; *p = head, *s;//定义指向ListNode数据类型的p与s指针，且p=head=null for (j = 0; j &lt; i; j++) &#123; p = p-&gt;next;//循环使p指向第i-1个结点 &#125; s = new ListNode &lt; T &gt; ;//创建新结点 s-&gt;data = x;//x赋值给该新开辟的结点 s-&gt;next = p-&gt;next;//原第i个结点的地址赋值给新开辟的结点的指针域 p-&gt;next = s;//将新开辟的结点的地址赋值给原指向第i个结点的地址。&#125;//在第i个结点的位置上插入一个数据域为x的结点template&lt;class T&gt;void LinkList&lt;T&gt;::DeleteNode(int i, T &amp;x)&#123; if (i&lt;1 || i&gt;ListLength()) &#123; cout &lt;&lt; \"position error!\"; return; &#125; for (j = 0; j &lt; i; j++)//循环 &#123; s = p;//此时s指向第i-1个结点 p = p-&gt;next;//此时p指向第i个结点 &#125; x = p - data;//取处第i个结点的数据域中的值 s-&gt;next = p-&gt;next;//将第i个结点中的指针域的值赋予第i-1个结点的指针域，使得由第i-1个结点直接到第i+1个结点 delete p;//释放p指向的结点的内存&#125;//删除第i个结点template&lt;class T&gt;void LinkList&lt;T&gt;::PrintList()&#123; ListNode&lt;T&gt; *p = head-&gt;next; while (p) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; \" \"; p = p-&gt;next; &#125; cout &lt;&lt; endl;&#125;//遍历输出链表template&lt;class T&gt;void split(LinkList&lt;T&gt; L, LinkList&lt;T&gt; &amp;A, LinkList&lt;T&gt; &amp;B)&#123; ListNode&lt;T&gt; *p, *a, *b; p = L.head-&gt;next;//p指向第一个结点 A.head = a = L.head;//初始化a为A的头结点的指针，值为L的头结点的值 B.head = b = new ListNode &lt; T &gt; ; while (p != NULL) &#123; a-&gt;next = p;//使A的头结点的指针域为p即指向第一个结点 a = p;//使指向第一个结点，在总的过程中a始终指向A链表的最后一个结点 p = p-&gt;next;//p指向下一个结点即L链表的第二个结点 if (p) &#123; b-&gt;next = p;//L链表第二个节点的地址赋予B链表头结点的指针域，使其成为B链表的第一个结点 b = p;//使b指向第二个结点，在总的过程中b始终指向B链表的最后一个结点 p = p-&gt;next;//p指向下一个结点即L链表的第三个结点 &#125; &#125; a - next = b-&gt;next = NULL;&#125;//单链表分解 12 使用实例123456789101112#include\"stdio.h\"#include\"iostream\"#include \"MyLlist.h\"using namespace std;void main()&#123; LinkList&lt;char&gt; L; char ch = 'e'; L.CreateList(); L.PrintList();&#125; 12","categories":[],"tags":[]},{"title":"","slug":"【前端】动态登陆窗口","date":"2019-10-18T15:53:10.648Z","updated":"2019-10-18T16:29:46.673Z","comments":true,"path":"2019/10/18/【前端】动态登陆窗口/","link":"","permalink":"http://yangxinyang777.github.io/2019/10/18/【前端】动态登陆窗口/","excerpt":"【前端】动态登陆窗口","text":"【前端】动态登陆窗口 效果展示 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;MainWin&quot;&gt;​ &lt;h1 class=&quot;head &quot;&gt;欢迎&lt;/h1&gt;​ &lt;form action=&quot;&quot; onsubmit=&quot;return true&quot;&gt;​ &lt;h1&gt;用户名:&lt;/h1&gt;​ &lt;input type=&quot;text&quot; id=&quot;name&quot; placeholder=&quot;请输入用户名...&quot;&gt;&lt;br/&gt;​ &lt;h1&gt;密码:&lt;/h1&gt;​ &lt;input type=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码...&quot;&gt;&lt;br/&gt;​ &lt;input type=&quot;button&quot; value=&quot;确定&quot; class=&quot;button&quot; onclick=&quot;window.open(&apos;index.html&apos;)&quot;&gt;​ &lt;input type=&quot;submit&quot; value=&quot;注册&quot; class=&quot;button&quot;&gt;​ &lt;form/&gt;​ &lt;/div&gt;​ &lt;/div&gt; &lt;style&gt;​ body&#123;​ margin: 0;​ padding: 0;​ background-color: #573c4c;​ &#125;​ body , html&#123;​ height: 100%;​ &#125;​ .main&#123;​ /*margin:20% auto 20% auto;*/​ margin-top: 0 ;​ padding: 0;​ height: 100%;​ width: 100%;​ background-color: #757575;​ /* background:url(&quot;pic/login_backgroud.jpg&quot;) no-repeat;​ background-size:100% 100%; */​ position:absolute;​ display: flex;​ /*一种布局方式*/​ justify-content: center;​ /*使main处于bady中心*/​ align-items: center;​ /*居中对齐main中的div元素*/​ &#125;​ .MainWin&#123;​ padding: 20px;​ background-color:#fff;​ height: 250px;​ width: 350px;​ &#125;​ .head&#123;​ font-size: 50px;​ color: #757575;​ text-align: center;​ &#125;​ .MainWin h1&#123;​ font-family: &quot;微软雅黑&quot;;​ font-size: 15px;​ color: #757575;​ &#125;​ .MainWin input[type=&quot;text&quot;], input[type=&quot;password&quot;]&#123;​ border: none;​ border-bottom: 3px solid #757575;​ width: 100%;​ padding: 5px 0;​ letter-spacing: 1px;​ transition: border-bottom-color .45s ;​ &#125;​ .MainWin input[type=&quot;button&quot;]&#123;​ margin-right:8.5%;​ margin-top: 10%;​ border: 2px solid #fff;​ width: 45%;​ height: 30px;​ background-color: #1eeb8e;​ color: #fff;​ transition: border .5s;​ /*position: absolute;*/​ &#125;​ .MainWin input[type=&quot;submit&quot;]&#123;​ margin-top: 10%;​ border: 2px solid #fff;​ width: 44%;​ height: 30px;​ background-color: #1eeb8e;​ color: #fff;​ transition: border .5s;​ /*position: absolute;*/​ &#125;​ .MainWin input[type=&quot;button&quot;]:hover&#123;​ border: 2px solid #1eeb8e;​ &#125;​ .MainWin input[type=&quot;submit&quot;]:hover&#123;​ border: 2px solid #1eeb8e;​ &#125;​ .MainWin input[type=&quot;text&quot;]:hover&#123;​ border-bottom-color: #f7abe9;​ &#125;​ .MainWin input[type=&quot;password&quot;]:hover&#123;​ border-bottom-color: #f7abe9;​ &#125;​ &lt;/style&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"","slug":"数据结构学习笔记01","date":"2019-10-18T14:48:56.509Z","updated":"2019-10-18T15:12:01.707Z","comments":true,"path":"2019/10/18/数据结构学习笔记01/","link":"","permalink":"http://yangxinyang777.github.io/2019/10/18/数据结构学习笔记01/","excerpt":"【数据结构】chapter 1","text":"【数据结构】chapter 1 思维导图 补充ADT (Abstract Data Type)一个定义了相关操作运算的数学模型，以“圆”为例。（C语言） ADT Circle{ ​ Date //数据 ​ 非负实数 //作为半径 ​ Operations //操作 ​ Constructor //建立 ​ 输入：非负实数 ​ 处理：给圆的半径赋值 ​ Area //求面积 ​ 输入：半径 ​ 处理：计算面积 ​ 输出：面积 ​ Circumference //求周长 ​ 输入：半径 ​ 处理：计算周长 ​ 输出：周长 }// ADT Circle 这样，就建立了一个Cricle抽象数据类型，定义在该数据类型上的一些操作为：Constructor、Area、Circleumference","categories":[],"tags":[]},{"title":"","slug":"基于高德地图WebAPI的WebGIS前端界面搭建","date":"2019-10-13T14:14:06.620Z","updated":"2019-10-18T15:52:29.641Z","comments":true,"path":"2019/10/13/基于高德地图WebAPI的WebGIS前端界面搭建/","link":"","permalink":"http://yangxinyang777.github.io/2019/10/13/基于高德地图WebAPI的WebGIS前端界面搭建/","excerpt":"基于高德地图WebAPI的WebGIS前端页面搭建","text":"基于高德地图WebAPI的WebGIS前端页面搭建 成果展示登陆界面 主界面 基本概念WebGIS 什么是WebGIS？就是将GIS这门学科所能提供的功能，以B/S技术展现给用户，使用户只需要在浏览器上便能使用这些GIS功能。与其他全栈式开发相同，但WebGIS更侧重的是在应用层的地图服务。 前端如所有的Web项目一样，前端由HTML、CSS、JS、Flex等语言组成。 中间件开发时，我们要选择适合自己的中间件。不同的中间件有其特性，如果是一般项目，tomcat等是很合适的，其使用方便，相关技术支持和资料也很好查找。但是如果是大型的集群项目，Weblogic和WebShpere可能是更好的选择，但是这两个中间件首先配置就是有难度的，同时不同的版本，可能对某些jar包的支持存在问题。如果项目必须使用国产的中间件，TongWeb和Apusics是不错的选择。 地图服务器在WebGIS中，与其他一般的Web工程有明显区别的就体现在地图服务器上面。一般的地图服务器都由已有的软件商提供了解决方案，比较流行的有AGS、Geoserver、MapServer、SuperServer等。利用这些地图服务器我们能很好的实现地图的发布以及对一些空间查询和空间操作的支持。 业务服务器业务服务器是Web项目里不可获取的一环。不管是利用哪些已有框架编写，比如Spring、Struts、Hibernate等，我们一般还是会将业务服务器的实现分为三个层次，即有名的MVC模式。而不同的框架里这三个层次的实现各有差别。 数据WebGIS的数据大致可以分为三种，一种是地图、影像数据，一种是空间属性数据、一种是业务数据。地图、影像数据一般是一些png或者其他格式的数据组成。 在GIS中有个很重要的概念，即影像金字塔。这个概念主要是为了加速地图在前端的显示。而我们准备地图、影像数据时，也一般会首先对这些数据进行切图。 空间属性数据，是通过一些工具将已经整理好的数据进行入库。对于AGS，只有连接的是入库数据的mxd，才能发布成FeatureServer服务，以供数据的编辑。当然，空间数据入库后还可以支持业务逻辑的使用。 第三种数据，业务逻辑数据，是每个Web项目必须有的，它根据不同的业务需求将业务所需的数据进行采集和入库。 前端框架动态登陆窗口二级下拉菜单高德地图WebAPI调用","categories":[],"tags":[]}]}